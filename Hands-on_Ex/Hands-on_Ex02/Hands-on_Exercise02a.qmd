---
title: "Hands-on Exercise 2a"
author: "Stefanie Felicia"
date: "September 4, 2025"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  warning: false
  freeze: true
---

## Getting Started

Objective of this exercise is to evaluate pattern or distribution of a set of points on a surface (e.g. events or business services or facilities). In this hands-on exercise, we'll specifically explore first-order spatial point pattern analysis (1st SPPA).

First-order Spatial Point Pattern Analysis focus on understanding intensity of points across a study area since they vary across different study area. But the analysis don't consider the interactions between individual location of points and distributions. The analysis also answers questions like **where are points are densely located**, **how spread out the point patterns are** and **if the density uniform or vary across space**.

In this exercise, we'll be using spatstat specifically to answer these questions:

-   Are childcare centres in Singapore randomly distributed throughout the country ?

-   If not, which location have higher childcare centres ?

## Import Libraries

```{r}
pacman::p_load(sf, terra, spatstat, 
               tmap, rvest, tidyverse)
```

The libraries used in this exercise would be:

-   sf: simple features in R to encode and analyze spatial vector data

-   tmap: used to draw thematic map

-   rvest: help scrape data from web page

-   spatstat: spatial statistics with focus on analyzing spatial point patterns in SD (with some 3D support)

-   terra: methods for spatial data analysis with vector (points. lines, polygons) and raster (grid) data

-   tidyverse: collection of R packages that for data manipulation and visualization

## The Data

In this hands-on exercise, we'll be using the following datasets:

-   <a href="https://data.gov.sg/collections/1749/view">Master Plan 2019 Subzone Boundary (No Sea)</a>

-   <a href="https://data.gov.sg/datasets/d_5d668e3f544335f8028f546827b773b4/view">Child Care Sevices</a>

## Import and Wrangle Geospatial Data

First, we'll import the Master Plan 2019 Subzone Boundary (No Sea) in kml file.

```{r}
mpsz_sf <- st_read("data/Master Plan 2019 Subzone Boundary (No Sea) (KML).kml") %>% 
  st_zm(drop = TRUE, what = "ZM") %>% st_transform(crs = 3414)
```

The st_zm() is used to remove Z (elevation) and M (measure) dimensions from geospatial geometries.

Next, we'll build a function to extract attributes like REGION_N, PLN_AREA_N, SUBZONE_N and SUBZONE_C from HTML Description column in the KML file and filter out unwanted SUBZONE_N and PLN_AREA_N.

```{r}
extract_kml_field <- function(html_text, field_name) {
  if (is.na(html_text) || html_text == "") return(NA_character_)
  
  page <- read_html(html_text)
  rows <- page %>% html_elements("tr")
  
  value <- rows %>%
    keep(~ html_text2(html_element(.x, "th")) == field_name) %>%
    html_element("td") %>%
    html_text2()
  
  if (length(value) == 0) NA_character_ else value
}
```

```{r}
mpsz_sf <- mpsz_sf %>%
  mutate(
    REGION_N = map_chr(Description, extract_kml_field, "REGION_N"),
    PLN_AREA_N = map_chr(Description, extract_kml_field, "PLN_AREA_N"),
    SUBZONE_N = map_chr(Description, extract_kml_field, "SUBZONE_N"),
    SUBZONE_C = map_chr(Description, extract_kml_field, "SUBZONE_C")
  ) %>%
  select(-Name, -Description) %>%
  relocate(geometry, .after = last_col())
```

```{r}
mpsz_cl <- mpsz_sf %>%
  filter(SUBZONE_N != "SOUTHERN GROUP",
         PLN_AREA_N != "WESTERN ISLANDS",
         PLN_AREA_N != "NORTH-EASTERN ISLANDS")
```

```{r}
write_rds(mpsz_cl, 
          "data/mpsz_cl.rds")
```

Next, we'll import the Childcare Service data.

```{r}
childcare_sf <- st_read("data/ChildCareServices.kml") %>% 
  st_zm(drop = TRUE, what = "ZM") %>%
  st_transform(crs = 3414)
```

### Mapping Geospatial Datasets

```{r}
tm_shape(mpsz_cl) +
  tm_polygons(col = "lightgrey", border.col = "white") +
tm_shape(childcare_sf) +
  tm_dots(col = "red", size = 0.1)

```

We can also make it into interactive plot by using tmap_mode()

```{r}
tmap_mode('view')
tm_shape(childcare_sf)+
  tm_dots()
```

```{r}
tmap_mode('plot')
```

### Geospatial Data Wrangling

spatstat relies on its own specific data structures like **ppp** (planar point pattern) for **point data and** **owin** **to observe data on specific region (or called windows)**. In this section, we'll convert sf objects into spatstat ppp and owin object.

#### Convert Data Frames to ppp Class

spatstat requires the point event data in ppp object form. We'll use the `as.ppp()` to convert the dtaset to ppp format

```{r}
childcare_ppp <- as.ppp(childcare_sf)
```

To verify the object class, we'll use the `class()` function.

```{r}
class(childcare_ppp)
```

We'll also take a look at the summary statistics

```{r}
summary(childcare_ppp)
```

#### Create owin Object

Owin object is designed to represent polygonal region. We can do that by using `as.owin()` function to convert sf object to owin.

```{r}
sg_owin <- as.owin(mpsz_cl)
```

We use `class()` to check the object class

```{r}
class(sg_owin)
```

We can now display the owin object using `plot()`

```{r}
plot(sg_owin)
```

#### Combine owin and ppp Objects

We can finally combine both objects by using the code below

```{r}
childcareSG_ppp = childcare_ppp[sg_owin]
```

```{r}
childcareSG_ppp
```

### Clark-Evan Test for Nearest Neighbor Analysis

Clark-evans test is a statistical method that utilizes the mean nearest neighbor distance (taking the mean of distances between each point to its nearest neighbor) **to check if a point pattern is clustered, random or uniformly spaced**. The test uses aggregation index (R) to describe the pattern:

-   R \< 1 signifies a clustered point pattern

-   R = 1 signify random point pattern

In this section, we'll be using Clark-evans test using clarkevans.test(), in which the test hypotheses are:

-   H0: The distribution are randomly distributed

-   H1: The distribution are not randomly distributed

and the 95% Confidence Interval will be used. For more information on the full arguments available, <a href="https://search.r-project.org/CRAN/refmans/spatstat.explore/html/clarkevans.test.html">click here</a>.

#### Perform Clark-Evans test without CSR

We can perform Clark-Evans test without CSR as the clarkevans.test() supports testing without CRS

```{r}
clarkevans.test(childcareSG_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"))
```

#### Perform Clark-Evans test with CSR

In this section, we'll be using the MonteCarlo method, in which the test is computed by comparing the observed value of R to results obtained from nsim (i.e. 39, 99, 999) simulated realizations of Complete Spatial Randomness conditional on observed number of points.

```{r}
clarkevans.test(childcareSG_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"),
                method="MonteCarlo",
                nsim=99)
```

### Kernel Density Estimation Method

Kernel Density Estimation is valuable tool for visualizing and analyzing first-order spatial point patterns and is usually used for EDA because it can be used to visualize and understand spatial data patterns by transforming point faya into continuous density surfaces that reveal clusters and variations in event occurrences without making prior assumptions about data distributions.

#### Working with Automatic Bandwidth Selection Method

To use kernel density, we'll be using the `density()` function.

```{r}
kde_SG_diggle <- density(
  childcareSG_ppp,
  sigma=bw.diggle,
  edge=TRUE,
  kernel="gaussian") 
```

::: {.callout-tip title="What does the code do"}
-   bw.diggle() automatic bandwidth selection method. Ther are other methods e.g. bw.CvL(), bw.scott() and bw.ppl()

-   `kernel` argument is the smoothing kernel. It is used for ..., the defualt value is "gaussian, but there are other smoothing methods available e.g. "epancechnikov", "quartic" and "disc"

-   `edge` argument applies edge correction (meaning kernel that overlap the boundary are renormalized so they don't lose mass). the default value for this argument is FALSE

-   The function outputs an im class, which represents a 2D pixel image. It's a class used to store and manipulate raster data, where the spatial domain is divide to a grid of rectangular pixels
:::

The plot() function can be used to display the kernel density derived.

```{r}
plot(kde_SG_diggle)
```

We can use summary() function to print the summary report

```{r}
summary(kde_SG_diggle)
```

Before moving to the next step, it's good to know that we can retrieve the bandwidth used to compute the kde layer

```{r}
bw <- bw.diggle(childcareSG_ppp)
bw
```

#### Rescaling KDE Values

As we saw in the summary, the output range was from 0 to 0.0003727443 which is a very small number which makes it difficult to comprehend. This is because the default unit of measurement of svy21 is in meters. So, we can rescale.ppp() to convert the unit of measurement to km.

```{r}
childcareSG_ppp_km <- rescale.ppp(
  childcareSG_ppp, 1000, "km")
```

We can re-apply the function

```{r}
kde_childcareSG_km <- density(childcareSG_ppp_km,
                              sigma=bw.diggle,
                              edge=TRUE,
                              kernel="gaussian")
```

And plot the kde object again

```{r}
plot(kde_childcareSG_km)
```

#### Working with Different Automatic Bandwidth Methods

In this section, we'll explore other functions i.e. `bw.CvL()`, `bw.scott()` and `bw.ppl()` to determine bandwidth.

First, let's look at `bw.CvL()` function, which uses the Cronie and van Lieshout's criterion based on Cambell's formula to select a smoothing bandwidth. For more information about the function, check out the <a href="https://search.r-project.org/CRAN/refmans/spatstat.explore/html/bw.CvL.html">documentation</a>.

```{r}
bw.CvL(childcareSG_ppp_km)
```

Next, we'll look at `bw.scott()`, which utilizes Scott's rule of thumb to determine smoothing bandwitdth. To learn more about the function, check out the <a href="https://www.rdocumentation.org/packages/spatstat/versions/1.64-1/topics/bw.scott">documentation</a>.

```{r}
bw.scott(childcareSG_ppp_km)
```

`bw.ppl()` uses likelihood cross-validation to choose smoothing bandwidth. Learn more about it in the <a href="https://search.r-project.org/CRAN/refmans/spatstat.explore/html/bw.ppl.html">documentation</a>.

```{r}
bw.ppl(childcareSG_ppp_km)
```

Note that `bw.diggle()` uses cross-validation to select smoothing bandwidth.

```{r}
bw.diggle(childcareSG_ppp_km)
```

Based on Baddeley et. (2016), it is suggested that bw.ppl() algorithm is used because it tend to produce more appropriate values when the pattern consists predominantly of tight clusters. But if the purpose of the study is to detect a single tight cluster, then bw.diggle() works best. Below shows the comparison between using `dw.diggle()` and `bw.ppl()`.

```{r}
kde_childcareSG.ppl <- density(childcareSG_ppp_km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_childcareSG_km, main = "bw.diggle")
plot(kde_childcareSG.ppl, main = "bw.ppl")
```

#### Working with Different Kernel Methods

Kernel methods are weighting function that determines how much influence each data point has on the estimate around it. There are a few kernel methods available in spatstats, i.e. Epanechnikov, gaussian (default), Quartic and Disc. In this section, we'll use compute the kernel density estimations using Epanechnikov, Quartic and Disc kernel function.

```{r}
par(mfrow=c(2,2))
plot(density(childcareSG_ppp_km, 
             sigma=0.2959712, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Gaussian")
plot(density(childcareSG_ppp_km, 
             sigma=0.2959712, 
             edge=TRUE, 
             kernel="epanechnikov"), 
     main="Epanechnikov")
plot(density(childcareSG_ppp_km, 
             sigma=0.2959712, 
             edge=TRUE, 
             kernel="quartic"), 
     main="Quartic")
plot(density(childcareSG_ppp_km, 
             sigma=0.2959712, 
             edge=TRUE, 
             kernel="disc"), 
     main="Disc")
```

#### Fixed and Adaptive KDE

We ca also compute KDE layer by defining a fixed bandwidth of 600 meter.

```{r}
kde_childcareSG_fb <- density(childcareSG_ppp_km,
                              sigma=0.6, 
                              edge=TRUE,
                              kernel="gaussian")
plot(kde_childcareSG_fb)
```

Th code uses `sigma = 0.6` argument since the unit measurement of the object is in kilometer instead of meter.

However, since fixed bandwidth is sensitive to highly skew distribution of spatial point patterns over geographical units (e.g. urban vs rural). So we can use adaptive bandwidth instead.

```{r}
kde_childcareSG_ab <- adaptive.density(
  childcareSG_ppp_km, 
  method="kernel")
plot(kde_childcareSG_ab)
```

#### Plotting Cartographic Quality KDE Map

First, we will convert the im kernel density object to SpatRaster object by using the rast() from terra library.

```{r}
kde_childcareSG_bw_terra <- rast(kde_childcareSG_km)
```

We can confirm if the object now is a SpatRaster class by using `class()`.

```{r}
class(kde_childcareSG_bw_terra)
```

We can also check for its properties.

```{r}
kde_childcareSG_bw_terra
```

The crs property, which tells us how the cell coordinates relate to real-world location (latitude and longitude), is empty. we can assign the crs to 3414 by using `crs()`.

```{r}
crs(kde_childcareSG_bw_terra) <- "EPSG:3414"
```

We can re-check the properties again to confirm the changes.

```{r}
kde_childcareSG_bw_terra
```

Now, we can finally plot KDE map with tmap liek below

```{r}
tm_shape(kde_childcareSG_bw_terra) + 
  tm_raster(col.scale = 
              tm_scale_continuous(
                values = "viridis"),
            col.legend = tm_legend(
            title = "Density values",
            title.size = 0.7,
            text.size = 0.7,
            bg.color = "white",
            bg.alpha = 0.7,
            position = tm_pos_in(
              "right", "bottom"),
            frame = TRUE)) +
  tm_graticules(labels.size = 0.7) +
  tm_compass() +
  tm_layout(scale = 1.0)
```

Now, we can see the density values in latitude/longitude as the raster values are encoded explicitly to raster pixel using values in layer.1 field.

### First Order SPPA at Planning Subzone Level

In this section, a further analysis at planning area level will be conducted (specifically, Punggol, Tampines, Choa Chu Kang and Jurong West).

#### Data Wrangling

We'll extract the target planning areas.

```{r}
pg <- mpsz_cl %>%
  filter(PLN_AREA_N == "PUNGGOL")
tm <- mpsz_cl %>%
  filter(PLN_AREA_N == "TAMPINES")
ck <- mpsz_cl %>%
  filter(PLN_AREA_N == "CHOA CHU KANG")
jw <- mpsz_cl %>%
  filter(PLN_AREA_N == "JURONG WEST")
```

And review the extracted areas.

```{r}
par(mfrow=c(2,2))
plot(st_geometry(pg), main = "Ponggol")
plot(st_geometry(tm), main = "Tampines")
plot(st_geometry(ck), main = "Choa Chu Kang")
plot(st_geometry(jw), main = "Jurong West")
```

Like before, we'll create the owin and combine with point events objects.

```{r}
pg_owin = as.owin(pg)
tm_owin = as.owin(tm)
ck_owin = as.owin(ck)
jw_owin = as.owin(jw)
```

```{r}
childcare_pg_ppp = childcare_ppp[pg_owin]
childcare_tm_ppp = childcare_ppp[tm_owin]
childcare_ck_ppp = childcare_ppp[ck_owin]
childcare_jw_ppp = childcare_ppp[jw_owin]
```

And then use rescale.ppp() to change unit of measurement from meter to kilometer.

```{r}
childcare_pg_ppp.km = rescale.ppp(childcare_pg_ppp, 1000, "km")
childcare_tm_ppp.km = rescale.ppp(childcare_tm_ppp, 1000, "km")
childcare_ck_ppp.km = rescale.ppp(childcare_ck_ppp, 1000, "km")
childcare_jw_ppp.km = rescale.ppp(childcare_jw_ppp, 1000, "km")
```

Below are the visualization of locations of childcare centres in each planning subzone area.

```{r}
par(mfrow=c(2,2))
plot(unmark(childcare_pg_ppp.km), 
  main="Punggol")
plot(unmark(childcare_tm_ppp.km), 
  main="Tampines")
plot(unmark(childcare_ck_ppp.km), 
  main="Choa Chu Kang")
plot(unmark(childcare_jw_ppp.km), 
  main="Jurong West")
```

#### Clark-Evans Test

The `clarkevans.test()` is used to for each planning area

```{r}
clarkevans.test(childcare_ck_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999) #choa chu kang
```

```{r}
clarkevans.test(childcare_tm_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999) # tampines
```

```{r}
clarkevans.test(childcare_pg_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999) # punggol
```

```{r}
clarkevans.test(childcare_jw_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999) #jurong west
```

#### Compute KDE Surfaces by Planning Area

Below, we'll use `bw.diggle()` to derive bandwidth of each planning area

```{r}
par(mfrow=c(2,2))
plot(density(childcare_pg_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tempines")
plot(density(childcare_ck_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Choa Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Jurong West")
```
